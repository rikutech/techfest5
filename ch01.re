= RailsエンジニアはPhoenixの夢を見るか？

はじめまして、LIDDELL Inc.でリードエンジニア(自称)をしている今(コン)といいます。

一応iOSチームのリーダーなんですが、あまりカッチリした境界があるわけではないのでVue.js、Rails、Laravelらへんを触ったりアレやコレやを節操なくワチャワチャしてます。エセフルスタックです。


さて、私からは最近個人的にお熱なElixir製Webフレームワーク「Phoenix」についてお話したいと思います。
弊社の一部サービスではバックエンドにRailsを導入していますが、ある程度規模が大きくなってきたときに抱えるつらさを感じつつあります。

「Modelが抱える責務が多すぎる…」「大量のテストコードにはもうウンザリ…」「色々な課題を解決するためにクラス構成拡張しまくったけどこれもうRailsじゃなくてよくね？」
あるあるですね。Railsというフレームワークはミニマムであまりスケール予定のないアプリケーションをサクッと作るには良いのですが、スケーラビリティという面ではいささか頼りない部分があります。
そこで奥さん、Phoenixですよ。
PhoenixはRailsに影響を受けつつも現代風に進化しているので、Railsのつらみを色々と解決してくれています。

== そもそもElixirってどんな言語よ

具体的なRailsとPhoenixの比較に入る前に、まずは簡単にElixirの説明からはじめましょう。
Elixirは動的型付け言語です。動的型付けではありますが、Erlangの実行バイナリににコンパイルすることができます。JVM上で動作するGroovyのようなものですね。
Elixirは関数型言語でもあります。関数型というと、オブジェクト指向エンジニアからは「なんか難しそう」といった印象だと思いますが、そんなことないんですよ。ここではとりあえず、「関数型言語には副作用がない(同じ関数に同じ引数を渡せば常に結果は同じになる)」ということだけ覚えておいてください。

さぁ、それではElixirのコードを見ていきましょう。

//list[1][index.exs][elixir]{
defmodule Main do def greet(name) do
    IO.puts "Hello, #{String.capitalize(name)}!"
  end
end

#実行結果
> Main.greet("kon")
Hello, Kon!
:ok
//}

めっっっちゃRuby。めっちゃRubyです。特に説明をしなくても上記のコードが何をしているかは一目瞭然でしょう。

何を隠そう、このElixirという言語の作者であるJosé Valim氏はRailsのコアコミッターなのです。ということは、ElixirはRubyを溺愛する人間が新天地を求めて生み出した言語なわけです。これは期待が膨らんでしまいますね。

もう少しElixirらしいコードを見ていきましょう。

//list[2][index.exs][elixir]{

defmodule Main do
  def sum_to(0), do: 0
  def sum_to(n) when is_integer(n) do
    cond do
      n > 0 -> n + sum_to(n - 1)
      n < 0 -> n + sum_to(n + 1)
    end
  end
  def sum_to(_), do: raise "整数以外は使えないよ！"
end

#実行結果
> Main.sum_to(10)
55
//}

ここではパターンマッチ・ガード節・再帰というElixirの強力な武器をたっぷり使ってみました。1つずつ見ていきましょう。

Rubyに慣れた人が見ると、sum_toが複数定義されてるかのように見えるでしょう。
更に、引数に0という具体的な値や謎の_が定義されていることに奇妙さを覚えるのではないでしょうか。実は、これこそがパターンマッチです。
Elixirでは、関数が呼び出されたときに上から順番に該当する関数をチェックしていきます。
その中で最初に引数が条件にマッチしたものを目的の関数として呼び出します。上から見てみましょう。
1つ目のsum_to(0)は、引数が0のときに呼び出されます。0までの和は0と定義します。
2つ目のsum_to(n)は、ここだけを見れば0以外の全ての値にマッチしそうですが、whenの中でnがintegerであることを期待しています。これがガード節です。
3つ目のsum_to(_)は、上2つにマッチしなかった場合、つまり整数以外の全ての値にマッチします。_はあらゆる値にマッチしますが、その値が何にも使われないことを明示的にします。
ここでは整数以外の数に対する処理を定義しないため、引数の値にかかわらず例外を発生させています。
次にsum_to(n)の中身を見ていきましょう。ここでは新たなsum_toを呼び出す再帰処理が行われています。
condはelse ifを並列に書ける文法です。ここではnが0より大きいときにはnより1小さい値を、小さいときには1大きい値を再びsum_toに渡しています。
sum_to(n)は内部で新しいsum_toを呼び続けますが、最終的にはsum_to(0)が呼び出され0を返します。全てのsum_toが実行された後、和が返されます。
具体的には、5を渡すとこのような結果になるのがおわかりでしょうか。

5 + (4 + (3 + (2 + (1 + (0)))))

再帰自体は関数型言語特有のものではありませんが、とりわけ関数型によく見られるテクニックです。というのも、関数型言語には一時変数という概念がなかったり、非推奨だったりするからです。
他言語におけるループに取って代わるものが再帰といえるでしょう。

最後に、僕がとりわけお気に入りの文法、パイプ演算子を紹介しましょう。

//list[3][index.exs][elixir]{
(1..10) |> Enum.map(fn n -> n*n end) |> Enum.filter(fn n -> n < 40 end)
//}

いやぁ、素晴らしいですね。パイプ演算子(|>)は左側の値を右側の関数の第1引数として渡します。まさにUNIX哲学で言うところの「すべてのプログラムをフィルタとして設計する」を体現しているようです。fnはラムダ式を定義しますが、シンタックスシュガーを用いると以下のようにも書けます。
//list[4][index.exs][elixir]{
(1..10) |> Enum.map(&(&1*&1)) |> Enum.filter(&(&1 < 40))
//}

Rubyだったら以下のように書くでしょうか。

//list[5][index.rb][ruby]{
(1..10).map {|n| n*n}.select {|n| n < 40}
//}

書き方としては、Rubyのほうがスッキリしているような印象を受けるかもしれませんね。
しかし、オブジェクト指向における「obj.method(arg)」の実態が「method(self, arg)」であることを考えるとElixirの書き方はプログラムの実態に即していると言えないでしょうか。

Elixirの基本的な文法については以上です。
それでは、RailsとPhoenixの比較に入りましょう。

== Railsのここがつらいよ！ & Phoenixならこうできるよ！

Railsは既に14年の歴史があるWebフレームワークです。
Convention over Configuration(設定より規約)を掲げ、圧倒的に自由な記述ができるRubyに、Web開発のレール(規約)を敷き、典型的なCRUDアプリケーションを高速開発できる、当時からしたら画期的なフレームワークでした。
Rubyの今日の地位は、Railsによるものと言っても過言ではないでしょう。

しかし、この十数年でWebの世界はより繁栄し、複雑化や多様化が進んできました。
多様な消費者ニーズに答えるため、複雑なビジネス要件をアプリケーションの文脈に落とし込む必要がでてきたのです。
それは私や、もしかしたらこれを読んでいる貴方が在籍している小〜中規模のベンチャーにとっても同様で、シンプルで簡単なプロダクトを扱うとは限らなくなってきたのです。
更に、膨大なリクエスト数を並列に捌いたり、高速なレスポンスが求められるようにもなっています。
つまり、RailsのようなモノリシックでシンプルなCRUDアプリケーションに特化したフレームワークは、ベンチャー企業であっても最適解とは言えなくなっているのです。
上記の事実を踏まえると、生産性と並列性、実行速度、スケーラビリティなどを兼ね備えたフレームワークが最強ということになりますが…そんなフレームワークがあるわけ…

あったわ。Phoenixがあったわ。
そうなんです。Phoenix、全部あるんです。1つずつ見ていきましょう。

=== Model VS. Context & Schema
RailsにおけるModel、ActiveRecordが中々つらいことには皆さんウンウンと頷いてくれることでしょう。
ActiveRecordを使うと、必然的にModelとテーブルが1対1になります。
この制約によりビジネスロジックがテーブル構造に依存し、えてして歪みを生みます。
更には、scopeやcallback、validationもModel内に書けてしまうため、何も考えずに処理を書いていくとすぐにFatModelになってしまいます。後からリファクタリングしようと思っても、オブジェクト指向ゆえの複雑な状態が邪魔をして中々難しいものがあります。南無三。

さぁ、Phoenixに話を戻しましょう。
PhoenixではContextという概念を採用しています。
ドメイン駆動設計を知っている方はContextという言葉に馴染みがあるでしょうが、ここで言うContextは、ドメイン駆動設計で言うところのContextとは別物であることに注意してください。
カタログと注文のシステムを分けるためのシステムというより、注文のマスタデータと、それに紐づく商品データや決済データをまとめ上げて1つの注文情報という形で取り扱うような、集約に近いものになります。

文章で説明するより実際のコードを見ていきましょう。
Scaffoldのように自動生成

//流れを再確認
//ベース
//
//view・presenter
//テスト